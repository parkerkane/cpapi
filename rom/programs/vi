--[[
Copyright (c) 2011 Parker Kane <parker@friikz.net>

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be included
in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
--]]

if cp == nil then
    error('Requires ComputerPark API to run')
end

local tArgs = { ... }

local app = cp.App.new()

if #tArgs == 0 then
    error("Usage: vi <path>")
end

local Keys = cp.Keys
local Modes = { view = 0, edit = 1, ex = 2, search = 3, hold = 4 }

local mode = Modes.view;

local filename = shell.resolve(tArgs[1])
local readonly = fs.isReadOnly(filename)

if fs.exists(filename) and fs.isDir(filename) then
    error("Cannot edit a directory")
end

local w, h = term.getSize()
local x, y = 1, 1
local scrollX, scrollY = 0, 0
local cmdPos = 1
local cmdBuffer = ""
local repeatCount = 0

local searchString = ""
local searchPositionX = 0
local searchPositionY = 0
local holdMessage
local lastChar
local dirty = false

local buffer = {}
local yankBuffer = {}

local function load(filename)
    buffer = {}

    if fs.exists(filename) then
        local file = io.open(filename)

        repeat
            local line = file:read()
            table.insert(buffer, line)

            until not line
    else
        table.insert(buffer, "")
    end
end

local function save(filename)
    local file = io.open(filename, "w")
    if file then
        for n, sLine in ipairs(buffer) do
            file:write(sLine .. "\n")
        end
        file:close()
    end
end

local function updateCursorPosition()

    local realX = math.min(x - scrollX, buffer[y]:len() + 1)

    term.setCursorBlink(true)
    term.setCursorPos(realX, y - scrollY)
end

local function setMode(newMode)
    mode = newMode
    repeatCount = 0
end

local function updateStatus()

    term.setCursorPos(1, h)
    term.clearLine()

    if mode == Modes.view or mode == Modes.edit then
        term.setCursorPos(5, h)

        local realX = math.min(x - scrollX, buffer[y]:len() + 1)
        term.write('L' .. y .. ' C' .. realX)

        term.write(' Y' .. #yankBuffer)

        if mode == Modes.edit then
            term.setCursorPos(w - 15, h)
            term.write('** INSERT **')
        end

        updateCursorPosition()

    elseif mode == Modes.ex then
        term.write(':' .. cmdBuffer)

        term.setCursorPos(1 + cmdPos, h)

    elseif mode == Modes.hold then
        term.write(holdMessage)

    elseif mode == Modes.search then
        term.write('/' .. cmdBuffer)

        term.setCursorPos(1 + cmdPos, h)
    end
end

local function updateLine()
    local line = buffer[y]
    term.setCursorPos(1 - scrollX, y - scrollY)
    term.clearLine()
    term.write(line)
    term.setCursorPos(x - scrollX, y - scrollY)
end

local function updateScreen()
    for y = 1, h - 1 do
        term.setCursorPos(1 - scrollX, y)
        term.clearLine()

        local line = buffer[y + scrollY]
        if line ~= nil then
            term.write(line)
        else
            term.write('~')
        end
    end

    updateCursorPosition()
    updateStatus()
end

local function updateCursor(key)

    if key == Keys.left or key == 'h' then
        x = math.min(x, buffer[y]:len() + 1)
        x = x - 1

        if mode == Modes.edit and x == 0 and y > 1 then
            local newy = math.max(1, y - 1)
            x = buffer[newy]:len() + 1

            os.queueEvent('key', Keys.up)
        elseif mode == Modes.view then
            x = math.max(x, 1)
        end

    elseif key == Keys.right or key == 'l' then
        x = x + 1

        if mode == Modes.edit and x > buffer[y]:len() + 1 and y ~= #buffer then
            x = 1
            os.queueEvent('key', Keys.down)
        elseif mode == Modes.view then
            x = math.min(x, buffer[y]:len() + 1)
        end

    elseif key == Keys.up or key == 'k' then
        y = math.max(1, y - 1)
--        x = math.min(x, buffer[y]:len() + 1)

    elseif key == Keys.down or key == 'j' then
        y = math.min(y + 1, #buffer)
--        x = math.min(x, buffer[y]:len() + 1)
    end

    local update = false

    if key == true then update = true end

    while x - scrollX < 1 do
        scrollX = scrollX - 10

        if scrollX < 0 then
            scrollX = 0
            x = 1
        else
            update = true
        end
    end

    while x - scrollX > w do
        scrollX = scrollX + 10
        update = true
    end

    while y - scrollY < 1 do

        scrollY = scrollY - 3
        if scrollY < 0 then scrollY = 0 end

        update = true
    end

    while y - scrollY > h - 1 do
        scrollY = scrollY + 3

        if scrollY > #buffer - h + 1 then
            scrollY = #buffer - h + 1
        end

        update = true
    end

    if update then
        updateScreen()
    else
        updateStatus()
    end
end

local function yank()
    yankBuffer = {}
    repeatCount = math.max(1, repeatCount)

    for i = 0, repeatCount - 1 do
        if y + i > #buffer then break end

        table.insert(yankBuffer, buffer[y + i])
    end

    repeatCount = 0
end

local function pasteYank()
    local i = 0

    table.foreach(yankBuffer, function(idx, line)
        table.insert(buffer, y + i, line)
    end)
end

local function runExCommand(cmd)
    if cmd == 'q' then
        os.queueEvent('quit')

    elseif cmd == 'w' then
        save(filename)

    elseif cmd == 'wq' or cmd == 'x' then
        save(filename)
        os.queueEvent('quit')

    elseif cmd == 'sh' then
        term.clear()
        term.setCursorPos(1, 1)
        shell.run('shell')
        print()

        updateScreen()

    elseif cmd == 'wr' then
        save(filename)

        term.clear()
        term.setCursorPos(1, 1)
        shell.run('/' .. filename)

        setMode(Modes.hold)
        holdMessage = 'Press any key to continue..'

    elseif cmd == 'r' then
        load(filename)
        x = 1
        y = 1
        updateCursor()
        updateScreen()

    elseif tonumber(cmd) ~= nil then
        x = 1
        y = math.min(#buffer, tonumber(cmd))
        updateCursor()
    end
end

local function doSearch(reverse)
    searchPositionX = x
    searchPositionY = y

    if reverse then

        -- TODO reverse search
    else
        for i = searchPositionY, #buffer do
            local newPos = buffer[i]:find(searchString, searchPositionX + 1, true)
            searchPositionX = 0

            if newPos ~= nil then
                x = newPos
                y = i

                searchPositionX = x
                searchPositionY = y

                updateCursor()
                updateScreen()
                return
            end
        end
    end

    holdMessage = "String '" .. searchString .. "' not found."
    setMode(Modes.hold)
end

local function repeatable(func)
    local function r(...)
        local c = math.max(1, repeatCount)

        for i = 1, c do
            func(...)
        end

        repeatCount = 0
    end

    return r
end

local viewModeListener = {
    [Keys.up] = repeatable(updateCursor);
    [Keys.down] = repeatable(updateCursor);
    [Keys.left] = repeatable(updateCursor);
    [Keys.right] = repeatable(updateCursor);

    h = repeatable(updateCursor);
    j = repeatable(updateCursor);
    k = repeatable(updateCursor);
    l = repeatable(updateCursor);

    i = function()
        setMode(Modes.edit)
        updateStatus()
    end;

    a = function()
        x = math.min(buffer[y]:len() + 1, x + 1)
        setMode(Modes.edit)
        updateStatus()
    end;

    I = function()
        setMode(Modes.edit)
        x = 1
        updateStatus()
    end;

    A = function()
        setMode(Modes.edit)
        x = buffer[y]:len() + 1
        updateStatus()
    end;

    o = repeatable(function()
        setMode(Modes.edit)
        x = 1
        y = y + 1
        table.insert(buffer, y, "")
        updateScreen()
        dirty = true
    end);

    O = repeatable(function()
        setMode(Modes.edit)
        x = 1
        y = math.max(1, y - 1)
        table.insert(buffer, y, "")
        updateScreen()
        dirty = true
    end);

    [':'] = function()
        cmdPos = 1
        cmdBuffer = ""
        setMode(Modes.ex)
        updateStatus()
    end;

    ['$'] = function()
        x = buffer[y]:len() + 1
        updateCursor()
    end;

    ['^'] = function()
        x = 1
        updateCursor()
    end;

    ['0'] = function()

        if repeatCount > 0 then
            repeatCount = repeatCount * 10
            return
        end

        x = 1
        updateCursor()
    end;

    ['/'] = function()
        cmdPos = 1
        cmdBuffer = ""
        setMode(Modes.search)
        updateStatus()
    end;

    n = function()
        doSearch()
    end;

    L = function()
        updateScreen()
    end;

    G = function()

        if repeatCount == 0 then
            x = 1
            y = #buffer
        else
            x = 1
            y = math.min(repeatCount, #buffer)
        end

        updateCursor()

        repeatCount = 0
    end;

    Y = function()
        yank()
        updateStatus()
    end;

    p = repeatable(function()
        pasteYank()
        y = y + #yankBuffer
        updateCursor(true)
    end);

    P = repeatable(function()
        pasteYank()
        updateCursor(true)
    end);

    U = function()
        y = math.max(1, y - math.floor(h / 2))
        updateCursor()
    end;

    D = function()
        y = math.min(#buffer, y + math.floor(h / 2))
        updateCursor()
    end;

    B = function()
        y = math.max(1, y - h - 1)
        updateCursor()
    end;

    F = function()
        y = math.min(#buffer, y + h - 1)
        updateCursor()
    end;

    defaultChar = function(char)

        local c = tostring(lastChar) .. char

        if c == 'dd' then
            repeatable(function()
                table.remove(buffer, y)
                y = math.min(y, #buffer)
                updateCursor(true)
            end)()

            char = nil
        elseif c == 'yy' then
            yank()
            updateStatus()
        elseif tonumber(char) ~= nil then
            repeatCount = repeatCount * 10 + tonumber(char)
        end

        lastChar = char
    end;
}

local editModeListener = {
    [Keys.up] = updateCursor;
    [Keys.down] = updateCursor;
    [Keys.left] = updateCursor;
    [Keys.right] = updateCursor;

    [Keys.lctrl] = function()
        setMode(Modes.view)
        updateStatus()
    end;

    [Keys.rctrl] = function()
        setMode(Modes.view)
        updateStatus()
    end;

    [Keys.enter] = function()
        local line = buffer[y]

        buffer[y] = buffer[y]:sub(1, x - 1)
        table.insert(buffer, y + 1, line:sub(x))

        x = 1
        y = y + 1

        updateScreen()
        dirty = true
    end;

    [Keys.bspace] = function()

        if x > 1 then
            x = x - 1
            buffer[y] = buffer[y]:sub(1, x - 1) .. buffer[y]:sub(x + 1)
        elseif y > 1 then
            local ln = buffer[y - 1]:len()
            buffer[y - 1] = buffer[y - 1] .. buffer[y]
            table.remove(buffer, y)

            x = ln + 1
            y = y - 1
        end
        updateScreen()
        dirty = true
    end;

    [Keys.tab] = function()

        buffer[y] = buffer[y]:sub(1, x - 1) .. "  " .. buffer[y]:sub(x)

        x = x + 2
        updateLine()
        updateCursorPosition()
        updateCursor()
        dirty = true
    end;

    defaultChar = function(char)

        buffer[y] = buffer[y]:sub(1, x - 1) .. char .. buffer[y]:sub(x)
        x = x + 1
        updateLine()
        updateCursorPosition()
        updateCursor()
        dirty = true
    end
}

local exModeListener = {
    [Keys.lctrl] = function()
        setMode(Modes.view)
        updateStatus()
    end;

    [Keys.rctrl] = function()
        setMode(Modes.view)
        updateStatus()
    end;

    [Keys.left] = function()
        cmdPos = math.max(1, cmdPos - 1)
        updateStatus()
    end;

    [Keys.right] = function()
        cmdPos = math.min(cmdBuffer:len() + 1, cmdPos + 1)
        updateStatus()
    end;

    [Keys.bspace] = function()
        cmdPos = math.max(1, cmdPos - 1)
        cmdBuffer = cmdBuffer:sub(1, cmdPos - 1) .. cmdBuffer:sub(cmdPos + 1)

        updateStatus()
    end;

    [Keys.enter] = function()
        setMode(Modes.view)
        runExCommand(cmdBuffer)
        updateStatus()
    end;

    defaultChar = function(char)

        cmdBuffer = cmdBuffer:sub(1, cmdPos - 1) .. char .. cmdBuffer:sub(cmdPos)
        cmdPos = cmdPos + 1

        updateStatus()
    end
}

local holdListener = {
    defaultKey = function()
        setMode(Modes.view)
        updateScreen()
    end
}

local searchListener = {
    [Keys.lctrl] = function()
        setMode(Modes.view)
        updateStatus()
    end;

    [Keys.rctrl] = function()
        setMode(Modes.view)
        updateStatus()
    end;

    [Keys.left] = function()
        cmdPos = math.max(1, cmdPos - 1)
        updateStatus()
    end;

    [Keys.right] = function()
        cmdPos = math.min(cmdBuffer:len() + 1, cmdPos + 1)
        updateStatus()
    end;

    [Keys.bspace] = function()
        cmdPos = math.max(1, cmdPos - 1)
        cmdBuffer = cmdBuffer:sub(1, cmdPos - 1) .. cmdBuffer:sub(cmdPos + 1)

        updateStatus()
    end;

    [Keys.enter] = function()
        setMode(Modes.view)

        searchPositionX = 0
        searchPositionY = 1
        searchString = cmdBuffer

        doSearch()

        updateStatus()
    end;

    defaultChar = function(char)

        cmdBuffer = cmdBuffer:sub(1, cmdPos - 1) .. char .. cmdBuffer:sub(cmdPos)
        cmdPos = cmdPos + 1

        updateStatus()
    end
}

local allListeners = {
    [Modes.view] = viewModeListener,
    [Modes.edit] = editModeListener,
    [Modes.ex] = exModeListener,
    [Modes.search] = searchListener,
    [Modes.hold] = holdListener,
}

load(filename)

term.clear()

updateScreen()

app:main({
    key = function(keyCode)
        local listener = allListeners[mode]
        if listener == null then return end

        local func = listener[keyCode] or listener.defaultKey
        if func == nil then return end

        func(keyCode)
    end;

    char = function(char)
        local listener = allListeners[mode]
        if listener == null then return end

        local func = listener[char] or listener.defaultChar
        if func == nil then return end

        func(char)
    end;

    update = function()
    end;

    quit = function()
        term.clear()
        term.setCursorPos(1, 1)
    end;
})
